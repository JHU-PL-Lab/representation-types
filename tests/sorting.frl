
let rec partition = fun p l ->
    match l with
    | { Nil  : * } -> ( l; l )
    | { Cons : * } ->
        let parts = partition p l.tl in
        let hd = l.hd in
        if p hd then
            ( {.Cons; hd = hd; tl = parts.0}; parts.1 )
        else
            ( parts.0; {.Cons; hd = hd; tl = parts.1} )
    end
in

let rec concat = fun l1 l2 ->
    match l1 with
    | { Nil  : * } -> l2
    | { Cons : * } -> { .Cons; hd = l1.hd; tl = concat l1.tl l2 }
    end
in

let rec sort = fun l ->
    match l with
    | { Nil  : * } -> l
    (* | { Cons : * ; tl : { Nil : * } } -> l *)
    | { Cons : * } ->
        let hd = l.hd in
        let parts = partition (fun elem -> elem < hd) l.tl in
        let left  = sort parts.0 in
        let right = sort parts.1 in
        concat left {.Cons; hd = hd; tl = right}
    end
in

let rec read_input = fun l ->
    let n = input in
    if not (n == 0) then
        read_input {.Cons; hd = n; tl = l}
    else
        l
in

sort (read_input {.Nil})