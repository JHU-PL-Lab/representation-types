
let empty = {.Nil} in

let Red = fun data ->
    { Red = data@{} }
in
let Blk = fun data ->
    { Blk = data@{} }
in


let blacken = fun node ->
    match node with
    | { Red: * } -> { Blk = node.Red }
    | *          -> node
    end
in

let get_value = fun node ->
    match node with
    | { Red: * } -> node.Red.value
    | { Blk: * } -> node.Blk.value
    end
in

let map_data = fun node f ->
    match node with
    | { Red: * } -> Red (f node.Red)
    | { Blk: * } -> Blk (f node.Blk)
    end
in

let balance = fun tree ->
    match tree with
    | { Blk: * } ->
        let data = tree.Blk in
        match data with
        | { L: { Red: { R: { Red: * } } } } ->
            Red {
                value = data.L.Red.R.Red.value;
                L = Blk {
                    value = data.L.Red.value;
                    L = data.L.Red.L;
                    R = data.L.Red.R.Red.L;
                };
                R = Blk {
                    value = data.value;
                    L = data.L.Red.R.Red.R;
                    R = data.R;
                };
            }
        | { R: { Red: { R: { Red: * } } } } ->
            Red { 
                value = data.R.Red.value;
                L = Blk {
                    value = data.value;
                    L = data.L;
                    R = data.R.Red.L;
                };
                R = blacken data.R.Red.R;
            }
        | { R: { Red: { L: { Red: * } } } } ->
            Red {
                value = data.R.Red.L.Red.value;
                L = Blk {
                    value = data.value;
                    L = data.L;
                    R = data.R.Red.L.Red.L;
                };
                R = Blk {
                    value = data.R.Red.value;
                    L = data.R.Red.L.Red.R;
                    R = data.R.Red.R;
                };
            }
        | { L: { Red: { L: { Red: * } } } } ->
            Red {
                value = data.L.Red.value;
                L = blacken data.L.Red.L;
                R = Blk {
                    value = data.value;
                    L = data.L.Red.R;
                    R = data.R;
                };
            }
        | * ->
            tree
        end
    | * ->
        tree
    end
in

let insert = fun val tree ->
    match tree with
    | { Nil: * } -> 
        Red { value=val; L=empty; R=empty }
    | * ->
        let tree_val = get_value tree in
        if val < tree_val then
            balance (map_data tree (fun data -> data @ { L = insert val data.L }))
        else if val == tree_val then
            tree
        else
            balance (map_data tree (fun data -> data @ { R = insert val data.R }))
    end
in

let count_red = fun tree ->
    match tree with
    | { Blk : * } -> 
        count_red tree.Blk.L + count_red tree.Blk.R
    | { Red : * } -> 
        1 + count_red tree.Red.L + count_red tree.Red.R
    | { Nil : * } ->
        0
    end
in

let loop = fun t ->
    let n = input in
    if n == 0 then 
        count_red t
    else
        loop (blacken (insert n t))
in

loop empty